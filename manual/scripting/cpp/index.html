<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>C++ Scripting | Flax Documentation </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="C++ Scripting | Flax Documentation ">
    <meta name="generator" content="docfx 2.56.7.0">
    
    <link rel="shortcut icon" href="../../../favicon.ico">
    <link rel="stylesheet" href="../../../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../../../styles/docfx.css">
    <link rel="stylesheet" href="../../../styles/main.css">
    <meta property="docfx:navrel" content="../../../toc.html">
    <meta property="docfx:tocrel" content="../../toc.html">
    
    <meta property="docfx:rel" content="../../../">
    <meta property="docfx:newtab" content="true">
    
    <script async="" src="https://www.googletagmanager.com/gtag/js?id=UA-88357703-2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-88357703-2');
    </script>
  </head>	  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              <a class="navbar-brand" href="https://www.flaxengine.com">
        		<div style="text-align:center; line-height:45px">
        	    <img id="logo" height="40" width="40" src="../../../logo.png" alt="">
        		</div>
        	  </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div class="container body-content">
        
        <div id="search-results">
          <div class="search-list">Search Results for <span></span></div>
          <div class="sr-items">
            <p><i class="glyphicon glyphicon-refresh index-loading"></i></p>
          </div>
          <ul id="pagination" data-first="First" data-prev="Previous" data-next="Next" data-last="Last"></ul>
        </div>
      </div>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">
<h1 id="c-scripting">C++ Scripting</h1>

<p>Flax Engine supports fully C++ scripting with even more features than C# scripting. In general, C++ offers more <strong>performance</strong> and allows to <strong>access engine API directly</strong> which comes with many benefits. Flax Engine is mostly written in C++ with C# flavor which means you can easily build the game on top of the engine. Also, Flax uses its own build tool called <a href="../../editor/flax-build/index.html">Flax.Build</a> to compile both engine and game.</p>
<p>Follow this documentation section to learn how to write your own C++ scripts and use them in a game. Also, if you see any code examples in the <em>Flax Documentation</em> that are written in C# you can similarly use them in C++ scripts since the engine uses the same API in both languages (you can even move your existing game code from C# to C++ quite quickly).</p>
<h2 id="setup">Setup</h2>
<p>Flax Editor contains in-build C# compiler for scripts but for C++ scripting the platform-dependent toolset is required to be installed in the machine. Every platform uses its own native tools. To learn about them see this <a href="../../platforms/index.html">page</a>. Below you can learn quickly how to setup depending on your platform.</p>
<h4 id="windows">Windows</h4>
<ul>
<li>Install <strong>Visual Studio 2019</strong> or 2017 or 2015 (<a href="https://visualstudio.microsoft.com/en/vs/community/">download</a>)</li>
<li>Install <strong>Windows 10 SDK</strong> (or Windows 8.1 SDK)</li>
<li>Install <strong>Microsoft Visual C++</strong> (v140 toolset or newer)</li>
</ul>
<h4 id="linux">Linux</h4>
<ul>
<li>Install <a href="https://code.visualstudio.com/">Visual Studio Code</a></li>
<li>Install <a href="https://www.mono-project.com/download/stable/">Mono</a></li>
<li>Get compiler <code>sudo apt-get install clang lldb lld</code> (Clang 6 or newer)</li>
</ul>
<h2 id="how-to-create-c-script">How to create C++ script?</h2>
<p>By default, new Flax projects have default game module using C# scripting. You can learn more about modules and targets <a href="../../editor/flax-build/index.html">here</a>. After installing required tools, open <code>Source/&lt;module_name&gt;/&lt;module_name&gt;.Build.cs</code> (i.e. <code>Source/Game/Game.Build.cs</code>). This file is a build script for the code module and can specify its build environment and dependencies. It contains overriden <strong>Setup(BuildOptions options)</strong> method which performs the module initialization.</p>
<p>Find the <code>BuildNativeCode = false</code> line and change the value to <code>true</code> or add the following code at the end of the method:</p>
<pre><code class="lang-cs">BuildNativeCode = true;
</code></pre><p>Now, you can <strong>add new C++ script</strong> to the project and they will be compiled into the binary libraries and loaded by the engine. To do so, navigate in <em>Content Window</em> to that module sources folder <code>Source/&lt;module_name&gt;</code>, <em>right-click</em> and choose option <strong>C++ Script</strong>. Specify its name and confirm with <em>Enter</em>.</p>
<p><img src="media/new-cpp-script.png" alt="New Native Script C++"></p>
<p>Using Editor main menu <strong>generate scripts project files</strong> or right-click on a game project file and choose a similar option.</p>
<p><img src="media/project-files-generation.png" alt="Generate Scripts Project Files"></p>
<p>After that open the code project (eg. Visual Studio Solution). Ensure to use <strong>Editor.Development</strong> configuration and <strong>Win64</strong> platform (if you&#39;re working on Windows).</p>
<p><img src="media/cpp-scripts-visual-studio.png" alt="Visual Studio Scripts Project"></p>
<p>As you can see, Editor generated a simple Script from a template that overrides <code>OnEnable</code>, <code>OnDisable</code>, and <code>OnUpdate</code> methods similar to C# scripts. Open created <code>.cpp</code> file and add following code on top to include debug logging:</p>
<pre><code class="lang-cpp">#include &quot;Engine/Core/Log.h&quot;
</code></pre><p>Then add simple log instruction in <code>OnUpdate</code> method:</p>
<pre><code class="lang-cpp">void CppScript::OnUpdate()
{
    LOG(Info, &quot;Hello from C++!&quot;);
}
</code></pre><p>Go back to Editor so it autocompiles scripts or open it from Visual Studio with <strong>Local Windows Debugger</strong> button aka Debugger Start (or hit <em>F5</em>). Now, you can add the script to the Actor and see the message printed in Output Log every frame by your own C++ script.</p>
<p><img src="media/cpp-script-run.png" alt="C++ Script Runtime"></p>
<p>Feel free to start coding your game logic in C++!</p>
<h2 id="c-scripting-with-flax">C++ scripting with Flax</h2>
<p>Flax supports <strong>hot-reloading C++</strong> code in Editor which greatly improves the workflow. It works in the same way as for C# scripting and can be configured in Editor Options. You can also close Editor, compile scripts from Visual Studio and open project with Visual Studio debuggeer.</p>
<p>In many cases before using a specific API type (eg. <code>PointLight</code> actor or <code>Model</code> asset) you have to <strong>include a proper header file</strong> since Flax uses paradigm <em>include-only-what-you-see</em>. But if you want easily include all common header you can include <code>Engine/Core/Common.h</code>. Also, as you&#39;ve probably noticed the Visual Studio solution contains also <strong>Flax</strong> C++ project (in Flax folder). You can freely browse the Flax code to learn more about API and available code utilities. If you downloaded the engine from Flax Store then it will contain only header files. Flax header files use <strong>XML documentation tags</strong> and are almost 100% documented so working with them is fairly smooth as you can quickly learn what given method/field does. Those documentation comments are later parsed by the build tool and exposed to C# for scripting and editor tooltips.</p>
<p>Now, to understand some basic concepts related to C++ scripting in Flax let&#39;s analyze the following script that spawns decals on mouse clicks and places them at the geometry using raycast from mouse location:</p>
<pre><code class="lang-cpp">#pragma once

#include &quot;Engine/Scripting/Script.h&quot;
#include &quot;Engine/Content/AssetReference.h&quot;
#include &quot;Engine/Content/Assets/MaterialBase.h&quot;
#include &quot;Engine/Input/Input.h&quot;
#include &quot;Engine/Level/Level.h&quot;
#include &quot;Engine/Level/Actors/Camera.h&quot;
#include &quot;Engine/Level/Actors/Decal.h&quot;
#include &quot;Engine/Serialization/JsonTools.h&quot;
#include &quot;Engine/Physics/Physics.h&quot;

API_CLASS() class MYPROJECT_API MouseDecalShoot : public Script
{
API_AUTO_SERIALIZATION();
DECLARE_SCRIPTING_TYPE(MouseDecalShoot);

    // The decal material to use for spawned decals.
    API_FIELD() AssetReference&lt;MaterialBase&gt; DecalMaterial;

    // Spawns the decal at the given mouse screen position.
    API_FUNCTION() void SpawnDecal(const Vector2&amp; mousePos)
    {
        // Convert mouse position into the world-space ray and perform the raycast in physics scene
        const auto ray = Camera::GetMainCamera()-&gt;ConvertMouseToRay(mousePos);
        RayCastHit hit;
        if (Physics::RayCast(ray.Position, ray.Direction, hit))
        {
            // Create decal at hit point and add it to the scene
            auto decal = New&lt;Decal&gt;();
            decal-&gt;Material = DecalMaterial;
            decal-&gt;SetPosition(hit.Point);
            decal-&gt;SetDirection(hit.Normal);
            Level::SpawnActor(decal);
        }
    }

    // [Script]
    void OnUpdate() override
    {
        if (Input::GetMouseButtonDown(MouseButton::Left))
        {
            SpawnDecal(Input::GetMousePosition());
        }
    }
};

inline MouseDecalShoot::MouseDecalShoot(const SpawnParams&amp; params)
    : Script(params)
{
    // Enable ticking OnUpdate function
    _tickUpdate = true;
}
</code></pre><p>Some important notes to learn:</p>
<ul>
<li>You can use raw pointers to the assets but the safe way is with <code>AssetReference&lt;T&gt;</code> or <code>WeakAssetReference&lt;T&gt;</code></li>
<li>To reference scene objects and other scripts in a safe way <code>ScriptingObjectReference&lt;T&gt;</code> is preferred</li>
<li>Scripting classes can be visible in Editor and C# scripting needs to have <code>API_CLASS()</code> meta macro before and <code>DECLARE_SCRIPTING_TYPE(&lt;typename&gt;);</code> added</li>
<li>By default script objects contain a constructor that takes a single parameter <code>const SpawnParams&amp; params</code></li>
<li>To expose a field into the editor and C# scripting use <code>API_FIELD()</code> prefix macro that can contain additional metadata attributes</li>
<li>To expose a function to the editor and C# scripting use <code>API_FUNCTION</code> prefix macro</li>
<li>You can use engine API similar to C# (eg. Camera, Physics, Input...)</li>
<li>The <code>&lt;module_name&gt;_API</code> define used between <code>class</code> and class name (i.e. <code>class MYPROJECT_API MouseDecalShoot</code>) is to export the C++ class to public module symbols so it can be used by other code</li>
<li>You can manually override <code>Serialize</code>/<code>Deserialize</code> method or use <code>API_AUTO_SERIALIZATION</code> macro to automatically generate serialziation code for the type (for classes and structures that inherit from <code>ISerializable</code>)</li>
<li>If your game module uses types from various engine modules (eg. Graphics, Physics) you have to add a reference to the in a build script so build tools can handle modules dependencies and properly link binaries - simply add <code>options.PublicDependencies.Add(&quot;&lt;module_name&gt;&quot;);</code> in you build script (where module name is Physics/Terrain/etc. - see BuildScripts for all modules you can use)</li>
</ul>
<p>To learn about <strong>API_</strong> tags see <a href="../../editor/flax-build/api-tags.html">this documentation</a>.</p>
<p>Also, since C# and C++ API are very similar you can use this <a href="https://docs.flaxengine.com/api/FlaxEngine.html">API reference</a>.</p>
<h2 id="interop-with-c">Interop with C#</h2>
<p>To call C# from C++ you need to use engine managed scripting wrappers <code>MClass</code> and <code>MMethod</code> as in the following example:</p>
<pre><code class="lang-cs">public void CallMe()
{
   // Code in C#
}
</code></pre><pre><code class="lang-cpp">#include &quot;Engine/Scripting/ManagedCLR/MClass.h&quot;
#include &quot;Engine/Scripting/ManagedCLR/MMethod.h&quot;

...

Script* someCSharpScript = ...;
auto method = someCSharpScript-&gt;GetClass()-&gt;GetMethod(&quot;CallMe&quot;);
method-&gt;Invoke(someCSharpScript-&gt;GetOrCreateManagedInstance(), nullptr, nullptr);
</code></pre><p>This code will call parameter-less, member function named <em>CallMe</em> from the given object.</p>
<p>To call C++ from C# simply expose your type with <code>API_CLASS</code> to C# and expose the given method with <code>API_FUNCTION</code> tag too. The build tool will generate the glue code for native methods invocation from C#.</p>
<pre><code class="lang-cpp">API_FUNCTION() void CallMe()
{
   // Code in C++
}
</code></pre><pre><code class="lang-cs">NativeScript someCppScript = ...;
someCppScript.CallMe();
</code></pre></article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                  <li>
                    <a href="https://github.com/honzapatCZ/FlaxDocs/blob/master/manual/scripting/cpp/index.md/#L1" class="contribution-link">Improve this Doc</a>
                  </li>
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
                <h5>In This Article</h5>
                <div></div>
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            Copyright © 2012-2021 Wojciech Figat
            
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../../../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../../../styles/docfx.js"></script>
    <script type="text/javascript" src="../../../styles/main.js"></script>
  </body>
</html>
